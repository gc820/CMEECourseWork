Starting testing for Georgina, Week3

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 3.18 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: .git, week1, week2, Feedback, week3

Found the following files in parent directory: .gitignore, README.md

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:

**********************************************************************
*~ 
*.tmp
week*/sandbox/
**/results/*
!**/results/.gitkeep
__pycache__/
week4/

**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
# CMEE Coursework Repository

## Description
This repository hosts the CMEE bootcamp coursework and class files. It includes organized scripts, data, and documentation to support learning in areas such as shell scripting, Python programming, LaTeX, and R.

## Languages
- **Bash**: (version 5.2.21(1))
- **Python**: (version 3.12.3)
- **LaTeX**
- **R**: (version 4.3.3)

## Dependencies
- **Python**: Requires Python 3.12.3. Standard library modules used:
  - `csv`: For CSV file operations.
  - `sys`: For command-line interactions.
  - `doctest`: For embedded code testing.

These modules are part of Python’s standard library, so no additional installations are required. R scripts also use only the standard library.

## Installation
No installation is needed. All code can be executed directly in a terminal or compatible code editor.

## Project Structure and Usage
The project is organized to reflect the structure of the CMEE bootcamp, with coursework separated by weeks. Each weekly folder includes the following subdirectories:

- **code**: Contains runnable scripts for coursework tasks.
- **data**: Holds input data files required by the scripts.
- **results**: Stores output files generated by scripts, though this folder may be initially empty as output files are typically generated on demand.


### Usage Instructions
1. **Prepare the Environment**:
   - Ensure all required input files are placed in the `data` folder.
   - Open a terminal or code editor with terminal access.

2. **Run Scripts**:
   - Navigate to the folder containing the script you wish to run (usually found in `code`).
   - Execute Bash scripts by entering `bash <filename>.sh` in the terminal.
   - Run Python scripts with `python3 <filename>.py`.
   - Execute R scripts using `Rscript <filename>.R`.

3. **Example Command Execution**:
   - For Bash: `bash CompileLaTeX.sh`
   - For Python: `python3 align_seqs.py`
   - For R: `Rscript DataWrang.R`

4. **Output Files**:
   - Generated output files will automatically be saved in the `results` folder for easy tracking and organization.

5. **File Management**:
   - Avoid committing files in the `results` folder to version control unless necessary, as they are typically generated outputs.


## Author
Georgina Chow  
Email: [georgina.chow20@imperial.ac.uk](mailto:georgina.chow20@imperial.ac.uk)


**********************************************************************

======================================================================
Looking for the weekly directories...

Found 3 weekly directories: week1, week2, week3

The Week3 directory will be tested 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Testing WEEK3...

Found the following directories: results, data, code

Found the following files: requirements.txt, README.md

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
# CMEE Coursework: Week 3

## Description
This repository contains a collection of R scripts from the Week 3 CMEE bootcamp coursework. These files cover essential data processing, control flow, and visualization techniques in R.

## Languages
- **R**: (version 4.3.3, or later recommended)

## Dependencies
The R scripts in this repository may require the following packages for data processing, control flow, and visualization:

- **dplyr**: For efficient data manipulation and transformation.
- **ggplot2**: For creating visualizations.
- **tidyr**: For data tidying and reshaping.
- **readr**: For reading in CSV and other text files.

To install any of these packages, you can run:
```R
install.packages(c("dplyr", "ggplot2", "tidyr", "readr"))
```
The dependencies are listed in requirements.txt file. 

No additional installations are necessary for scripts using only base R functions.

## Project Structure and Usage 
This repository is organized by functionality to align with the bootcamp coursework content. Scripts for code processing, data management, visualization, and control structures are included in the code directory. All data should be placed in the data directory, and output files will be saved in the results folder.

## Code Descriptions
Each script is self-contained. Run any script by loading it with source("<filename>.R").
- **apply1.R & apply2.R**: Demonstrates `apply` family functions to process data structures.
  - **Input**: Takes matrices or lists.
  - **Output**: Returns processed structures.
  - **Usage**: `source("apply1.R")`
  - **Dependencies**: None

- **basic_io.R**: Functions for basic data input/output operations.
  - **Input**: `.csv` or `.txt` files.
  - **Output**: Processed data files.
  - **Usage**: `source("basic_io.R")`
  - **Dependencies**: `readr` for extended file types

- **boilerplate.R**: Template for initializing R scripts.
  - **Input**: None (template file).
  - **Output**: None (template setup).
  - **Usage**: Use as a template for new scripts.
  - **Dependencies**: None

- **break.R**: Illustrates `break` statements in loops.
  - **Input**: None
  - **Output**: Console output based on loop conditions.
  - **Usage**: `source("break.R")`
  - **Dependencies**: None

- **browse.R**: Tools for data inspection.
  - **Input**: Dataframes or lists.
  - **Output**: Console output for data inspection.
  - **Usage**: `source("browse.R")`
  - **Dependencies**: None

- **control_flow.R**: Demonstrates `if`, `else`, and `while` control flow.
  - **Input**: Conditional values.
  - **Output**: Console output based on control flow.
  - **Usage**: `source("control_flow.R")`
  - **Dependencies**: None

- **DataWrang.R**: Data wrangling functions for reshaping and cleaning data.
  - **Input**: Dataframes.
  - **Output**: Cleaned/reshaped data.
  - **Usage**: `source("DataWrang.R")`
  - **Dependencies**: `dplyr`, `tidyr`

- **Girko.R**: Visualizes mathematical models (e.g., Girko's circular law).
  - **Input**: Mathematical functions and parameters.
  - **Output**: Plot in results.
  - **Usage**: `source("Girko.R")`
  - **Dependencies**: `ggplot2`

- **MyBars.R**: Custom bar plot functions.
  - **Input**: Data for bar plot.
  - **Output**: Custom bar plot in results.
  - **Usage**: `source("MyBars.R")`
  - **Dependencies**: `ggplot2`

- **next.R**: Illustrates `next` statements in loops.
  - **Input**: None
  - **Output**: Console output showing skipped iterations.
  - **Usage**: `source("next.R")`
  - **Dependencies**: None

- **plotLin.R**: Linear plot functions.
  - **Input**: Data for linear plotting.
  - **Output**: Linear plot in results.
  - **Usage**: `source("plotLin.R")`
  - **Dependencies**: `ggplot2`

- **preallocate.R**: Demonstrates preallocation for memory efficiency.
  - **Input**: None
  - **Output**: Console output showing preallocated memory usage.
  - **Usage**: `source("preallocate.R")`
  - **Dependencies**: None

- **R_conditionals.R**: Examples of conditional statements.
  - **Input**: Conditional values.
  - **Output**: Console output based on conditionals.
  - **Usage**: `source("R_conditionals.R")`
  - **Dependencies**: None

- **Ricker.R**: Implements the Ricker model for population growth.
  - **Input**: Population data.
  - **Output**: Growth model output.
  - **Usage**: `source("Ricker.R")`
  - **Dependencies**: None

- **sample.R**: Sampling methods in R.
  - **Input**: Dataset to sample from.
  - **Output**: Sampled data.
  - **Usage**: `source("sample.R")`
  - **Dependencies**: None

- **TreeHeight.R**: Computes tree heights based on input data.
  - **Input**: Data for tree heights.
  - **Output**: Calculated tree heights.
  - **Usage**: `source("TreeHeight.R")`
  - **Dependencies**: None

- **try.R**: Error handling with `try`.
  - **Input**: Data with potential errors.
  - **Output**: Console output handling errors.
  - **Usage**: `source("try.R")`
  - **Dependencies**: None

- **Vectorize1.R & Vectorize2.R**: Demonstrates vectorization in R.
  - **Input**: Dataset.
  - **Output**: Console output with vectorized processing.
  - **Usage**: `source("Vectorize1.R")`
  - **Dependencies**: None

Each script is independent. Run any script by loading it with `source("<filename>.R")` and following the specific usage example provided in each file’s comments.

## Data
- `EcolArchives-E089-51-D1.csv`
- `PoundHillData.csv`
- `PoundHillMetaData.csv`
- `Results.txt`
- `trees.csv`

## Results
All results from the scripts will be saved in the `results` folder.

## Author
Georgina Chow  
Email: [georgina.chow20@imperial.ac.uk](mailto:georgina.chow20@imperial.ac.uk)

**********************************************************************

Results directory is empty - good! 

Found 18 code files: break.R, sample.R, Vectorize1.R, R_conditionals.R, apply1.R, basic_io.R, Girko.R, boilerplate.R, apply2.R, DataWrang.R, try.R, control_flow.R, MyBars.R, TreeHeight.R, plotLin.R, next.R, browse.R, preallocate.R

======================================================================
Testing script/code files...

======================================================================
Inspecting script file break.R...

File contents are:

**********************************************************************
#!/usr/bin/env Rscript

# File: break.R
# Author: Georgina Chow georgina.chow20@imperial.ac.uk
# Date: Oct 2024
# Description: This script demonstrates the use of the `break` statement to exit a `while` loop.
#              It iterates incrementally and exits when a specified condition is met.

# Usage:
# Run this script from an R session or command line.
# Example usage in R:
#   source("break.R")
#   # The script will print values of `i` from 0 to 9 and then exit the loop when `i` reaches 10.

# Dependencies:
#   Uses base R functions only; no additional packages are required.

# breaking out of loops
i <- 0 #Inisitaise i 
    while (i < Inf) {
        if (i ==10){
            break
        } else { # breal out fo the while loop!
            cat("i equals ", i, "\n")
            i <- i + 1 # Update i 
        }
    }
**********************************************************************

Testing break.R...

Output (only first 500 characters): 


**********************************************************************
i equals  0 
i equals  1 
i equals  2 
i equals  3 
i equals  4 
i equals  5 
i equals  6 
i equals  7 
i equals  8 
i equals  9 

**********************************************************************

Code ran without errors

Time consumed = 0.10654s

======================================================================
Inspecting script file sample.R...

File contents are:

**********************************************************************
#!/usr/bin/env Rscript


# File: sample.R
# Author: Georgina Chow georgina.chow20@imperial.ac.uk
# Date: Oct 2024
# Description: This script includes functions to calculate the mean of a sample 
#              drawn from a population, using various methods for iteration and 
#              vectorization. These functions demonstrate performance comparisons 
#              between methods such as loops with and without preallocation, 
#              as well as vectorized approaches using `lapply` and `sapply`.

# Usage:
# Run this script from an R session or command line.
# Example usage in R:
#   source("sample.R")
#   popn <- rnorm(1000)            # Define a population of 1000 random values
#   n <- 30                        # Sample size
#   num <- 50                      # Number of iterations
#   result1 <- loopy_sample1(popn, n, num)  # Without preallocation
#   result2 <- loopy_sample2(popn, n, num)  # With preallocation
#   result4 <- lapply_sample(popn, n, num)  # Using lapply

# Dependencies:
#   Uses base R functions only; no additional packages are required.

############### Functions ################

## A function to tale a sample of size n from a population "popn" and return its mean
myexperiment <- function(popn, n){ # Take sample size n from a population
    pop_sample <- sample(popn, n, replace = FALSE)
    return(mean(pop_sample)) # return the mean 
}

## Calculate means using a FOR loop on a vector without preallocation: 
loopy_sample1 <- function(popn, n, num) {
    result1 <- vector() #Initialize empty vector of size 1
    for(i in 1:num) {
        result1 <- c(result1, myexperiment(popn, n))
    }
    return(result1)
}

## To run "num" iterations of the experiment using a FOR loop on a vector with preallocation: 
loopy_sample2 <- function(popn, n, num) {
    result2 <- vector(, num) # Preallocate expected size
    for(i in 1:num) {
        result2[i] <- myexperiment(popn, n)
    }
    return(result2)
}

## To run "num" iterations of the experiment using a FOR loop on a list with preallocation: 
loopy_sample3 <- function(popn, n, num) {
    result3 <- vector("list", num) # Preallocate expected size
    for(i in 1:num) {
        result3[[i]] <- myexperiment(popn, n)
    }
    return(result3)
}

## To run "num" iterations of the experiment using vectorization with lapply:
lapply_sample <- function(popn, n, num) {
    result4 <- lapply(1:num, function(i) myexperiment(popn, n))
    return(result4)
}

## To run "num" iterations of the experiment using vectorization with sapply: 
sapply_sample <- function(popn, n, num) {
    result5 <- lapply(1:num, function(i) myexperiment(popn, n))
    return(result5)
}
**********************************************************************

Testing sample.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.08775s

======================================================================
Inspecting script file Vectorize1.R...

File contents are:

**********************************************************************
#!/usr/bin/env Rscript

# File: Vectorize1.R
# Author: Georgina Chow georgina.chow20@imperial.ac.uk
# Date: Oct 2024
# Description: This script compares the performance of a loop-based approach versus a 
#              built-in vectorized function for summing all elements in a matrix.

# Usage:
# Run this script from an R session or command line.
# Example usage in R:
#   source("Vectorize1.R")
#   # The script will automatically generate a 1000x1000 matrix of random numbers,
#   # and measure the execution time for both loop-based and vectorized summing methods.

# Dependencies:
#   Uses base R functions only; no additional packages are required.


M <- matrix(runif(1000000), 1000, 1000)

SumAllElements <- function(M) {
    Dimensions <- dim(M)
    Tot <- 0 
    for (i in 1:Dimensions[1]) {
        for (j in 1:Dimensions[2]) {
            Tot <- Tot + M[i,j]
        }
    }
    return (Tot)
}

print("Using loops, the time taken is:")
print(system.time(SumAllElements(M)))

print("Using the in-built vectorised function, the time taken is:")
print(system.time(sum(M)))
**********************************************************************

Testing Vectorize1.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Using loops, the time taken is:"
   user  system elapsed 
  0.029   0.002   0.031 
[1] "Using the in-built vectorised function, the time taken is:"
   user  system elapsed 
  0.000   0.000   0.001 

**********************************************************************

Code ran without errors

Time consumed = 0.15690s

======================================================================
Inspecting script file R_conditionals.R...

File contents are:

**********************************************************************
#!/usr/bin/env Rscript

# File: R_conditionals.R
# Author: Georgina Chow georgina.chow20@imperial.ac.uk
# Date: Oct 2024
# Description: This script includes functions that use conditionals to evaluate properties 
#              of numbers, such as whether they are even, powers of 2, or prime numbers.

# Usage:
# Run this script from an R session or command line.
# Example usage in R:
#   source("R_conditionals.R")
#   is.even(6)         # Checks if 6 is even
#   is.power2(4)       # Checks if 4 is a power of 2
#   is.prime(3)        # Checks if 3 is a prime number

# Dependencies:
#   Uses base R functions only; no additional packages are required.

##Functions with conditionals## 

# Checks if an integer is even 
is.even <- function(n = 2) {
    if (n %% 2 == 0) {
        return(paste(n, 'is even!'))
    } else {
    return(paste(n, 'is odd!'))
    }
}

is.even(6)

# Checks if a number is a power of 2 
is.power2 <- function(n=2) {
    if (log2(n) %% 1==0) {
        return(paste(n, 'is a power of 2!'))
    } else {
    return(paste(n, 'is not a power of 2!'))
        }
}

is.power2(4)

# Checks if a number is prime 
is.prime <- function(n) {
    if(n==0) {
        return(paste(n, 'is a zero!'))
    } else if (n==1) {
        return(paste(n, 'is just a unit!'))
    }

    ints <- 2:(n-1)

    if (all(n%%ints!=0)) {
        return(paste(n, 'is a prime!'))
    } else {
    return(paste(n, 'is a composite!'))
    }
}

is.prime(3)

**********************************************************************

Testing R_conditionals.R...

Output (only first 500 characters): 


**********************************************************************
[1] "6 is even!"
[1] "4 is a power of 2!"
[1] "3 is a prime!"

**********************************************************************

Code ran without errors

Time consumed = 0.08941s

======================================================================
Inspecting script file apply1.R...

File contents are:

**********************************************************************
#!/usr/bin/env Rscript

# File: apply1.R
# Author: Georgina Chow georgina.chow20@imperial.ac.uk
# Date: Oct 2024
# Description: This script demonstrates the use of the `apply` function in R to calculate 
#              the mean and variance of rows and the mean of columns in a matrix.

# Usage:
# Run this script from an R session or command line.
# Example usage in R:
#   source("apply1.R")
#   # The script will generate a 10x10 matrix of random numbers, calculate the row means, 
#   # row variances, and column means, and print the results.

# Dependencies:
#   Uses base R functions only; no additional packages are required.

## Build a random matrix 
M <- matrix(rnorm(100), 10, 10)

## Take the mean of each row 
RowMeans <- apply(M, 1, mean)
print(RowMeans)

## Now the variance 
RowVars <- apply(M, 1, var)
print(RowVars)

## By column 
ColMeans <- apply(M, 2, mean)
print(ColMeans)


**********************************************************************

Testing apply1.R...

Output (only first 500 characters): 


**********************************************************************
 [1]  0.07910287 -0.41810018 -0.07677175 -0.01959456 -0.05139539  0.24306315
 [7] -0.30589828 -0.30186162 -0.37704102  0.05754855
 [1] 1.33740052 0.54508881 1.03470966 0.08421342 0.60620151 0.73298852
 [7] 0.77827796 0.90734783 1.01468941 0.71220904
 [1] -0.20632868 -0.35983680  0.51826244  0.26069231 -0.01700189 -0.28755850
 [7] -0.04694149 -0.46816580 -0.05205617 -0.51201366

**********************************************************************

Code ran without errors

Time consumed = 0.09371s

======================================================================
Inspecting script file basic_io.R...

File contents are:

**********************************************************************
#!/usr/bin/env Rscript

# File: basic_io.R
# Author: Georgina Chow georgina.chow20@imperial.ac.uk
# Date: Oct 2024
# Description: This script demonstrates basic input-output operations in R. 
#              It reads data from a CSV file and writes it in various formats 
#              to an output file, showcasing options for headers, row names, 
#              and appending data.

# Usage:
# Run this script from an R session or command line.
# Example usage in R:
#   source("basic_io.R")
#   # The script will read `trees.csv` and save variations of this data to `../results/MyData.csv`.

# Dependencies:
#   Uses base R funct

# A simple script to illustrate R input-output
# Run line by line and check inputs outputs to understand what is happening 

MyData <- read.csv("../data/trees.csv", header=TRUE) # import with headers

write.csv(MyData, "../results/MyData.csv") # Write it out as a new file 

write.table(MyData[1,], file = "../results/MyData.csv", append=TRUE) # Append to it 

write.csv(MyData, "../results/MyData.csv", row.names=TRUE) # Write row names 

write.table(MyData, "../results/MyData.csv", col.names = FALSE) # ignore column names 

print("Script complete!")
**********************************************************************

Testing basic_io.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Script complete!"

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Warning message:
In write.table(MyData[1, ], file = "../results/MyData.csv", append = TRUE) :
  appending column names to file

======================================================================
Inspecting script file Girko.R...

File contents are:

**********************************************************************
#!/usr/bin/env Rscript

# File: Girko.R
# Author: Georgina Chow georgina.chow20@imperial.ac.uk
# Date: Oct 2024
# Description: This script visualizes the eigenvalues of a random matrix using the 
#              Girko circular law. It generates a scatter plot of the eigenvalues 
#              overlaid with an ellipse representing the theoretical boundary.

# Usage:
# Run this script from an R session or command line.
# Example usage in R:
#   source("Girko.R")
#   # The script will generate a plot of eigenvalues with an overlayed ellipse and 
#   # save it to `../results/Girko.pdf`.

# Dependencies:
#   Requires `ggplot2` package for plotting.
#   Install if needed: install.packages("ggplot2")

# Load necessary library
library(ggplot2)

# Plotting two dataframes together 
build_ellipse <- function(hradius, vradius){  #function that returns an ellipse 
    npoints = 250
    a <- seq(0, 2*pi, length = npoints + 1)
    x <- hradius * cos(a)
    y <- vradius * sin(a)
    return(data.frame(x=x, y=y))
}

N <- 250 # assign size of the matrix 
M <- matrix(rnorm(N*N), N, N) # Build the matrix 
eigvals <- eigen(M)$values # find eigenvalues 
eigDF <- data.frame("Real" = Re(eigvals), "Imaginary" = Im(eigvals)) # Build a dataframe
my_radius <- sqrt(N) # the radius of th circle is sqrt(N)
ellDF <- build_ellipse(my_radius, my_radius) # dataframe to plot the ellipse 
names(ellDF) <- c("Real", "Imaginary") # rename the columns 

# Plot the eigenvalues 
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))
p <- p +
  geom_point(shape = I(3)) +
  theme(legend.position = "none")

# now add the vertical and horizontal line
p <- p + geom_hline(aes(yintercept = 0))
p <- p + geom_vline(aes(xintercept = 0))

# finally, add the ellipse
p <- p + geom_polygon(data = ellDF, aes(x = Real, y = Imaginary, alpha = 1/20, fill = "red"))

pdf("../results/Girko.pdf")
print(p)
dev.off()
**********************************************************************

Testing Girko.R...

Output (only first 500 characters): 


**********************************************************************
null device 
          1 

**********************************************************************

Code ran without errors

Time consumed = 0.54018s

======================================================================
Inspecting script file boilerplate.R...

File contents are:

**********************************************************************
#!/usr/bin/env Rscript

# File: boilerplate.R
# Author: Georgina Chow georgina.chow20@imperial.ac.uk
# Date: Oct 2024
# Description: This is a boilerplate R script that defines a simple function, `MyFunction`,
#              which accepts two arguments, prints their values and types, and returns them as a vector.

# Usage:
# Run this script from an R session or command line.
# Example usage in R:
#   source("boilerplate.R")
#   MyFunction(1, 2)             # Test with numeric arguments
#   MyFunction("Riki", "Tiki")    # Test with character arguments

# Dependencies:
#   Uses base R functions only; no additional packages are required.


# A boilerplate R script 

MyFunction <- function(Arg1, Arg2) {

    # Statements involving Arg1, Arg2 
    print(paste("Argument", as.character(Arg1), "is a", class(Arg1))) # print Arg1 type
    print(paste("Argument", as.character(Arg2), "is a", class(Arg2))) # print Arg1 type

    return(c(Arg1, Arg2)) # (optional, but very useful)
}

MyFunction(1,2) # test the function
MyFunction("Riki", "Tiki") # A different test 
**********************************************************************

Testing boilerplate.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Argument 1 is a numeric"
[1] "Argument 2 is a numeric"
[1] 1 2
[1] "Argument Riki is a character"
[1] "Argument Tiki is a character"
[1] "Riki" "Tiki"

**********************************************************************

Code ran without errors

Time consumed = 0.09676s

======================================================================
Inspecting script file apply2.R...

File contents are:

**********************************************************************
#!/usr/bin/env Rscript

# File: apply2.R
# Author: Georgina Chow georgina.chow20@imperial.ac.uk
# Date: Oct 2024
# Description: This script demonstrates the use of the `apply` function in R to perform 
#              operations on rows of a matrix. It applies a custom function, `SomeOperation`, 
#              which multiplies each row by 100 if the sum of its elements is positive.

# Usage:
# Run this script from an R session or command line.
# Example usage in R:
#   source("apply2.R")
#   # The script will create a 10x10 matrix of random values, apply `SomeOperation` to each row, 
#   # and print the resulting matrix.

# Dependencies:
#   Uses base R functions only; no additional packages are required.

# Define a custom operation to apply to each row

SomeOperation <- function(v) { # Takses v as input 
    if (sum(v) > 0) { # If sum of v is >0 (both + and -)
        return (v * 100) # Multiply by 100 
    } else {
        return (v) 
    }
}

M <- matrix(rnorm(100), 10, 10)
print (apply(M, 1, SomeOperation))
**********************************************************************

Testing apply2.R...

Output (only first 500 characters): 


**********************************************************************
             [,1]        [,2]       [,3]        [,4]        [,5]       [,6]
 [1,] -0.19437059  137.674724  123.08650 -1.62060659  1.20358925 -0.8649476
 [2,] -2.36432999   20.039553  180.15101 -0.09822509 -1.99940654 -1.7608844
 [3,]  0.05978173  150.391487   40.19215  0.44075763  0.09377824 -0.2999879
 [4,] -0.38292193  -20.692672  -34.49490 -1.14794488 -0.98605549 -1.2809955
 [5,]  0.10995927 -113.724251  -94.28315 -0.84931472 -1.37204679 -1.1729876
 [6,]  0.29615279  -66.247419   70.71405 -0.7
**********************************************************************

Code ran without errors

Time consumed = 0.09994s

======================================================================
Inspecting script file DataWrang.R...

File contents are:

**********************************************************************
#!/usr/bin/env Rscript

# File: DataWrang.R
# Author: Georgina Chow georgina.chow20@imperial.ac.uk
# Date: Oct 2024
# Description: This script performs data wrangling on the Pound Hill dataset, converting 
#              raw data to a tidy format suitable for analysis. It involves transposing 
#              data, replacing missing values, converting to long format, and applying 
#              basic summary statistics.

# Usage:
# Run this script from an R session or command line.
# Example usage in R:
#   source("DataWrang.R")
#   # The script loads data, performs wrangling steps, and outputs a summary.

# Dependencies:
#   Requires `reshape2` and `tidyverse` packages for data manipulation.
#   Install if needed: 
#       install.packages("reshape2")
#       install.packages("tidyverse")

################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../data/PoundHillData.csv", header = FALSE))

# header = true because we do have metadata headers
MyMetaData <- read.csv("../data/PoundHillMetaData.csv", header = TRUE, sep = ";")

############# Inspect the dataset ###############
head(MyData)
dim(MyData)
str(MyData)
fix(MyData) #you can also do this
fix(MyMetaData)

############# Transpose ###############
# To get those species into columns and treatments into rows 
MyData <- t(MyData) 
head(MyData)
dim(MyData)

############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0

############# Convert raw matrix to data frame ###############

# Removes the 1st row 
TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
colnames(TempData) <- MyData[1,] # assign column names from original data

############# Convert from wide to long format  ###############
require(reshape2) # load the reshape2 package

?melt #check out the melt function

MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")

MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])

str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)

############# Exploring the data (extend the script below)  ###############

MyData[MyData == ""]= 0
MyData <- t(MyData)

head(MyData)
colnames(MyData) # R doesn't recognise the column headers 

# Important stringsAsFactors=F --> don't want R to convert columns to factor class
TempData <- as.data.frame(MyData[-1,], stringsAsFactors=F)
head(TempData)

colnames(TempData) <- MyData[1,] # Assign column names from original data
head(TempData)

rownames(TempData) <- NULL
head(TempData)

MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")
head(MyWrangledData); tail(MyWrangledData)

MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])
str(MyWrangledData)

require(tidyverse)
tidyverse_packages(include_self = TRUE) # the include_self = TRUE means list "tidyverse" as well 

# Convert the df to a tibble 

MyWrangledData <- dplyr::as_tibble(MyWrangledData)
MyWrangledData
MyWrangledData <- as_tibble(MyWrangledData)
class(MyWrangledData)

glimpse(MyWrangledData) # Similar to str() but nicer 
utils::View(MyWrangledData) # Same as fix()
filter(MyWrangledData, Count>100) #like subset() but nicer
slice(MyWrangledData, 10:15) # Look at a particular range of data rows 

MyWrangledData  %>% 
    group_by(Species)  %>% 
        summarise(avg = mean(Count))

#Can do the same using base R command (not dyplr)
aggregate(MyWrangledData$Count, list(MyWrangledData$Species), FUN=mean)


**********************************************************************

Testing DataWrang.R...

Output (only first 500 characters): 


**********************************************************************
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "october" "october" "october" "october"
[2,] "Block"                "a"       "a"       "a"       "a"       "a"      
[3,] "Plot"                 "1"       "1"       "1"       "1"       "1"      
[4,] "Quadrat"              "Q1"      "Q2"      "Q3"      "Q4"      "Q5"     
[5,] "Achillea millefolium" "4"       "8"       "3"       "20"      "6"      
[6,] "Agrostis gigantea"    ""   
**********************************************************************

Code ran without errors

Time consumed = 10.00951s

======================================================================
Inspecting script file try.R...

File contents are:

**********************************************************************
#!/usr/bin/env Rscript

# File: try.R
# Author: Georgina Chow georgina.chow20@imperial.ac.uk
# Date: Oct 2024
# Description: This script demonstrates the use of `try` for error handling within 
#              `lapply` and `for` loops. The function attempts to apply `doit` to each
#              element in a sequence of operations and handles errors gracefully.

# Usage:
# Run this script from an R session or command line.
# Example usage in R:
#   source("try.R")
#   # The script will attempt to run `doit` on each element and catch any errors, 
#   # returning results with error handling.

# Dependencies:
#   This script requires a predefined `doit` function and the variable `popn` 
#   to be defined before running.

# Example error-handling with `lapply` and `for` loop

# Using `lapply` to apply `doit` function and handle errors

result <- lapply(1:15, function(i) try(doit(popn), FALSE))
class(result)
result

result <- vector("list", 15) #Preallocate/Initialize
for(i in 1:15) {
    result[[i]] <- try(doit(popn), FALSE)
    }
**********************************************************************

Testing try.R...

Output (only first 500 characters): 


**********************************************************************
[1] "list"
[[1]]
[1] "Error in doit(popn) : could not find function \"doit\"\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in doit(popn): could not find function "doit">

[[2]]
[1] "Error in doit(popn) : could not find function \"doit\"\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in doit(popn): could not find function "doit">

[[3]]
[1] "Error in doit(popn) : could not find function \"doit\"\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleErro
**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"
Error in doit(popn) : could not find function "doit"

======================================================================
Inspecting script file control_flow.R...

File contents are:

**********************************************************************
#!/usr/bin/env Rscript

# File: control_flow.R
# Author: Georgina Chow georgina.chow20@imperial.ac.uk
# Date: Oct 2024
# Description: This script demonstrates basic control flow using `if` statements in R.
#              It includes examples of conditional checks and outputs messages based 
#              on the value of variables.

# Usage:
# Run this script from an R session or command line.
# Example usage in R:
#   source("control_flow.R")
#   # The script will evaluate predefined conditions and print results based on them.

# Dependencies:
#   Uses base R functions only; no additional packages are required.


## If statements ##

a <- TRUE 
if (a == TRUE) {
    print("a is TRUE")
} else {
    print("a is FALSE")
}

z <- runif(1) # Generate a uniformly distibuted random number
if (z <= 0.5) {
    print ("Less than a half")
    }
**********************************************************************

Testing control_flow.R...

Output (only first 500 characters): 


**********************************************************************
[1] "a is TRUE"
[1] "Less than a half"

**********************************************************************

Code ran without errors

Time consumed = 0.10033s

======================================================================
Inspecting script file MyBars.R...

File contents are:

**********************************************************************
#!/usr/bin/env Rscript

# File: MyBars.R
# Author: Georgina Chow georgina.chow20@imperial.ac.uk
# Date: Oct 2024
# Description: This script creates a bar plot with annotated line ranges using `ggplot2`. 
#              It customizes axis labels, removes the legend, and outputs the plot as a PDF.

# Usage:
# Run this script from an R session or command line.
# Example usage in R:
#   source("MyBars.R")
#   # The script will generate a line range plot and save it to `../results/MyBars.pdf`.

# Dependencies:
#   Requires `ggplot2` package for plotting.
#   Install if needed: install.packages("ggplot2")

# Ensure dataset `a` is defined with columns `x`, `y2`, `y3`, and `Label`
# Example data structure:
# a <- data.frame(x = ..., y2 = ..., y3 = ..., Label = ...)

# Load necessary library
library(ggplot2)

a <- read.table("../data/Results.txt", header = TRUE)

#Add a column of zeros for ymin in dataset 'a'
a$ymin <- rep(0, dim(a)[1]) # append a column of zeros 

#print the first linerange 
p <- ggplot(a)

p <- p + geom_linerange(data = a, aes(
                        x = x, ymin = ymin, 
                        ymax = y2, 
                        size = (0.5)), 
                        colour = "#56B4E9", 
                        alpha = 1/2, 
                        show.legend = FALSE)
# Print the third linerange:
p <- p + geom_linerange(data = a, aes(
                          x = x,
                          ymin = ymin,
                          ymax = y3,
                          size = (0.5)),
                        colour = "#D55E00",
                        alpha = 1/2, show.legend = FALSE)

# Annotate the plot with labels:
p <- p + geom_text(data = a, aes(x = x, y = -500, label = Label))

# now set the axis labels, remove the legend, and prepare for bw printing
p <- p + scale_x_continuous("My x axis", breaks = seq(3, 5, by = 0.05)) + 
                            scale_y_continuous("My y axis") + 
                            theme_bw() + 
                            theme(legend.position = "none") 
p

pdf("../results/MyBars.pdf")
print(p)
dev.off()
**********************************************************************

Testing MyBars.R...

Output (only first 500 characters): 


**********************************************************************
pdf 
  2 

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Warning message:
Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.
ℹ Please use `linewidth` instead. 
Warning message:
Removed 91 rows containing missing values or values outside the scale range
(`geom_text()`). 
Warning message:
Removed 91 rows containing missing values or values outside the scale range
(`geom_text()`). 

======================================================================
Inspecting script file TreeHeight.R...

File contents are:

**********************************************************************
#!/usr/bin/env Rscript

# File: TreeHeight.R
# Author: Georgina Chow georgina.chow20@imperial.ac.uk
# Date: Oct 2024
# Description: This script calculates the height of a tree given the distance 
#              from its base and the angle of elevation to its top, using 
#              trigonometry. The function `TreeHeight` takes angle and distance 
#              as arguments and returns the calculated tree height.

# Usage:
# Run this script from an R session or command line.
# Example usage in R:
#   source("TreeHeight.R")
#   TreeHeight(37, 40)  # Calculates tree height for a 37° angle and 40m distance

# Dependencies:
#   Uses base R functions only; no additional packages are required.


# This function calculates heights of trees given distance of each tree 
# from its base and angle to its top, using trigonometric formula 
#
# height = distance * tan(radians)
#
# ARGUMENTS
# degrees: The angle of elevation of tree
# distance: The distance from base of tree (e.g., meters) 
#
# OUTPUT
# The heights of the tree, same units as "distance"

# Define the TreeHeight function
TreeHeight <- function(degrees, distance) { 
    radians <- degrees * pi / 180 # Converts degrees to radians
    height <- distance * tan(radians) # Calculates the height using tangent function
    print(paste("Tree height is:", height))

    return(height) # Returns the calculated height as output 
}

# Example 
TreeHeight(37, 40)
**********************************************************************

Testing TreeHeight.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Tree height is: 30.1421620041118"
[1] 30.14216

**********************************************************************

Code ran without errors

Time consumed = 0.09110s

======================================================================
Inspecting script file plotLin.R...

File contents are:

**********************************************************************
#!/usr/bin/env Rscript

# File: plotLin.R
# Author: Georgina Chow georgina.chow20@imperial.ac.uk
# Date: Oct 2024
# Description: This script generates a scatter plot of simulated data with a linear 
#              regression line and mathematical annotations. It outputs the plot as a PDF.

# Usage:
# Run this script from an R session or command line.
# Example usage in R:
#   source("plotLin.R")
#   # The script generates a linear regression plot and saves it to `../results/MyLinReg.pdf`.

# Dependencies:
#   Requires `ggplot2` package for plotting.
#   Install if needed: install.packages("ggplot2")

## Linear regression plot annotation 
# Mathematical display 

# Creating 'data'
x <- seq(0, 100, by = 0.1)
y <- -4. + 0.25 * x + 
    rnorm(length(x), mean = 0., sd = 2.5)

# put in a data frame
my_data <- data.frame(x = x, y = y)

# perform a linear regression 
my_lm <- summary(lm(y ~ x, data = my_data))

# plot the data
p <- ggplot(my_data, aes(x=x, y=y, colour = abs(my_lm$residual))) +
    geom_point() +
    scale_colour_gradient(low="black", high="red") +
    theme(legend.position = "none") +
    scale_x_continuous(expression(alpha^2 * pi / beta *sqrt(Theta)))

# add the regression line 
p <- p + geom_abline(intercept = my_lm$coefficients[1][1],
    slope = my_lm$coefficients[2][1],
    colour = "red")

# throw some maths on the plot 
p <- p + geom_text(aes(x=60, y=0,
    label = "sqrt(alpha) * 2* pi"),
    parse = TRUE, size = 6, 
    colour = "blue")
p

pdf("../results/MyLinReg.pdf")
print(p)
dev.off()
**********************************************************************

Testing plotLin.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Error in ggplot(my_data, aes(x = x, y = y, colour = abs(my_lm$residual))) : 
  could not find function "ggplot"
Execution halted

======================================================================
Inspecting script file next.R...

File contents are:

**********************************************************************
#!/usr/bin/env Rscript

# File: next.R
# Author: Georgina Chow georgina.chow20@imperial.ac.uk
# Date: Oct 2024
# Description: This script demonstrates the use of the `next` statement in a loop. 
#              It prints only odd numbers from 1 to 10 by skipping even numbers.

# Usage:
# Run this script from an R session or command line.
# Example usage in R:
#   source("next.R")
#   # The script will output only the odd numbers from 1 to 10.

# Dependencies:
#   Uses base R functions only; no additional packages are required.

# Loop with 'next' statement to skipt even numbers 
for (i in 1:10) { 
   if ((i %% 2)== 0) # check if the number is odd 
   next # pass to the next iteration of the loop 
   print(i)
}
**********************************************************************

Testing next.R...

Output (only first 500 characters): 


**********************************************************************
[1] 1
[1] 3
[1] 5
[1] 7
[1] 9

**********************************************************************

Code ran without errors

Time consumed = 0.10264s

======================================================================
Inspecting script file browse.R...

File contents are:

**********************************************************************
#!/usr/bin/env Rscript

# File: browse.R
# Author: Georgina Chow georgina.chow20@imperial.ac.uk
# Date: Oct 2024
# Description: This script simulates exponential growth using a basic growth model and 
#              demonstrates the use of the `browser()` function for debugging purposes.
#              It includes a plot of the growth over generations.

# Usage:
# Run this script from an R session or command line.
# Example usage in R:
#   source("browse.R")
#   Exponential()  # Runs the exponential growth model and enters the debugger at each generation
#   plot(Exponential(), type = "l", main = "Exponential growth")  # Plots the growth model output

# Dependencies:
#   Uses base R functions only; no additional packages are required.

# Exponential growth function with debugging
Exponential <- function(N0 = 1, r = 1, generations = 10) {
    # Runs a simulations of eponential growth
    # Returns a vector of length generations 

    N <- rep(NA, generations) # Creates a vector of NA 

    N[1] <- N0 
    for (t in 2:generations) {
        N[t] <- N[t-1] * exp(r)
        browser()
    }
    return(N)
}

plot(Exponential(), type="l", main="Exponential growth")
**********************************************************************

Testing browse.R...

Output (only first 500 characters): 


**********************************************************************
Called from: Exponential()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()

**********************************************************************

Code ran without errors

Time consumed = 0.12332s

======================================================================
Inspecting script file preallocate.R...

File contents are:

**********************************************************************
#!/usr/bin/env Rscript

# File: preallocate.R
# Author: Georgina Chow georgina.chow20@imperial.ac.uk
# Date: Oct 2024
# Description: This script compares the performance of vector concatenation with 
#              and without preallocation. It includes two functions: `NoPreallocFun` 
#              and `PreallocFun`, which demonstrate the difference in execution time.

# Usage:
# Run this script from an R session or command line.
# Example usage in R:
#   source("preallocate.R")
#   NoPreallocFun(1000)   # Runs the function without preallocation
#   PreallocFun(1000)     # Runs the function with preallocation

# Dependencies:
#   Uses base R functions only; no additional packages are required.

## Pre-allocation ##

NoPreallocFun <- function(x) {
    a <- vector() # empty vector 
    for (i in 1:x) {
        a <- c(a, i) # concatenate 
    }
}

print(system.time(NoPreallocFun(1000)))

PreallocFun <- function(x) {
    a <- rep(NA, x) # Pre-allocated vector 
    for (i in 1:x) {
        a[i] <- i # assign 
    }
}

print(system.time(PreallocFun(1000)))
**********************************************************************

Testing preallocate.R...

Output (only first 500 characters): 


**********************************************************************
   user  system elapsed 
  0.007   0.001   0.010 
   user  system elapsed 
  0.002   0.000   0.002 

**********************************************************************

Code ran without errors

Time consumed = 0.12615s

======================================================================
======================================================================
Finished running scripts

Ran into 4 errors

======================================================================
======================================================================

FINISHED LOGGING

